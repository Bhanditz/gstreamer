<!-- ##### SECTION Title ##### -->
GstElement

<!-- ##### SECTION Short_Description ##### -->
Base class for all pipeline elements

<!-- ##### SECTION Long_Description ##### -->
<para>
GstElement is the base class needed to construct an element that can be
used in a GST pipeline.  As such, it is not a functional entity, and
cannot do anything when placed in a pipeline.
</para>

<para>
All GstElements have a list containing the #GstPad structure for all their
inputs and outputs.  These can be added with gst_element_add_pad() or
gst_element_add_ghost_pad(), and retrieved by name with
gst_element_get_pad(), or in a list form by gst_element_get_pad_list().
</para>

<para>
gst_element_connect() is a convenience function provided to make it
simpler to connect pads of two elements together.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### ENUM GstElementState ##### -->
<para>
This enum defines the standard states an element may be in.  GST_STATE_MAX
is the highest bit that can be set, and is used internally.

<informaltable pgwide=1 frame="none" role="enum">
<tgroup cols="2"><colspec colwidth="2*"><colspec colwidth="8*">
<tbody>
<row>
<entry>GST_STATE_COMPLETE</entry>
<entry>means all the necesary information is available to run, i.e. the
filename for the disksrc, etc. </entry>
</row>

<row>
<entry>GST_STATE_RUNNING</entry>
<entry>means that it's actually doing something, but that's fuzzy. </entry>
</row>

<row>
<entry>GST_STATE_DISCOVERY</entry>
<entry>is intended for the autoconnect case, in those instances where
the only way to determine the input or output type of some pad is for an
element to actually process some data.  The idea in that case is that the
source element would be responsible for sending the data non-destructively
(in the case of a network client, it would have to save it all up, unless
it has seek capabilities over the network), and all downstream elements
process it in such a way as to not hose their own state.  Or rather, when
they cease to do discovery, they completely wipe their state as if nothing
ever happened.</entry>
</row>

<row>
<entry>GST_STATE_PREROLL</entry>
<entry>is a local state, used for things like sending the first half of
an MPEG GOP through the decoder in order to start playback at a frame
somewhere in the middle of said GOP.  Not sure how that will work, 
exactly.</entry>
</row>

<row>
<entry>GST_STATE_PLAYING</entry>
<entry>means there really is data flowing
through the graph, where GST_STATE_PAUSED temporary stops the flow.  GST_STATE_PLAYING &&
GST_STATE_PAUSED is the same idea as !GST_STATE_PLAYING, but there are probably going to be
many cases where there really is a distinction.</entry>
</row>

</tbody></tgroup></informaltable>
</para>


<!-- ##### MACRO GST_STATE ##### -->
<para>
This macro returns the entire state of the element.
</para>

@obj: Element to return state for.


<!-- ##### MACRO GST_STATE_IS_SET ##### -->
<para>
This macro checks to see if the given state is set.
</para>

@obj: Element to check for state.
@flag: State to check for, must be a single bit in guint32.


<!-- ##### MACRO GST_STATE_SET ##### -->
<para>
This macro sets the given state on the element.
</para>

@obj: Element to set state of.
@flag: State to set, can be any number of bits in guint32.


<!-- ##### MACRO GST_STATE_UNSET ##### -->
<para>
This macro unsets the given state on the element.
</para>

@obj: Element to unset state of.
@flag: State to unset, can be any number of bits in guint32.


<!-- ##### STRUCT GstElement ##### -->
<para>

</para>


<!-- ##### STRUCT GstElementDetails ##### -->
<para>
This struct is used to define public information about the element.  It
describes the element, mostly for the benefit of editors.
</para>


<!-- ##### STRUCT GstElementFactory ##### -->
<para>
This factory is used when registering the element, and contains the name
of the element, the GtkType value for it, as well as a pointer to the
GstElementDetails struct for the element.
</para>


<!-- ##### USER_FUNCTION GstElementLoopFunction ##### -->
<para>
This function type is used to specify a loop function for the element.  It
is passed the element in question, and is expect to return only in error
circumstances.
</para>

@element: The element in question.


<!-- ##### FUNCTION gst_element_new ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION gst_element_set_loop_function ##### -->
<para>

</para>

@element: 
@loop: 


<!-- ##### FUNCTION gst_element_set_name ##### -->
<para>

</para>

@element: 
@name: 


<!-- ##### FUNCTION gst_element_get_name ##### -->
<para>

</para>

@element: 
@Returns: 


<!-- ##### FUNCTION gst_element_set_manager ##### -->
<para>

</para>

@element: 
@manager: 


<!-- ##### FUNCTION gst_element_get_manager ##### -->
<para>

</para>

@element: 
@Returns: 


<!-- ##### FUNCTION gst_element_add_pad ##### -->
<para>

</para>

@element: 
@pad: 


<!-- ##### FUNCTION gst_element_add_ghost_pad ##### -->
<para>

</para>

@element: 
@pad: 


<!-- ##### FUNCTION gst_element_get_pad ##### -->
<para>

</para>

@element: 
@name: 
@Returns: GList of pads


<!-- ##### FUNCTION gst_element_get_pad_list ##### -->
<para>

</para>

@element: 
@Returns: 


<!-- ##### FUNCTION gst_element_connect ##### -->
<para>

</para>

@src: 
@srcpadname: 
@dest: 
@destpadname: 
<!-- # Unused Parameters # -->
@srcpad: 
@destpad: 


<!-- ##### FUNCTION gst_element_set_state ##### -->
<para>

</para>

@element: 
@state: 
@Returns: 


<!-- ##### FUNCTION gst_element_error ##### -->
<para>

</para>

@element: 
@error: 


<!-- ##### FUNCTION gst_element_change_state ##### -->
<para>

</para>

@element: 
@state: 
@Returns: 


<!-- ##### MACRO gst_element_destroy ##### -->
<para>

</para>

@element: the element to destroy


<!-- ##### FUNCTION gst_element_save_thyself ##### -->
<para>

</para>

@element: 
@parent: 
@Returns: 


<!-- ##### FUNCTION gst_elementfactory_new ##### -->
<para>

</para>

@name: 
@type: 
@details: 
@Returns: 


<!-- ##### FUNCTION gst_elementfactory_register ##### -->
<para>

</para>

@elementfactory: 


<!-- ##### FUNCTION gst_elementfactory_find ##### -->
<para>

</para>

@name: 
@Returns: 


<!-- ##### FUNCTION gst_elementfactory_get_list ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION gst_elementfactory_create ##### -->
<para>

</para>

@factory: 
@name: 
@Returns: 


<!-- ##### FUNCTION gst_elementfactory_make ##### -->
<para>

</para>

@factoryname: 
@name: 
@Returns: 


<!-- ##### FUNCTION gst_element_loopfunc_wrapper ##### -->
<para>
</para>

@argc: 
@argv: 
@Returns: 


<!-- ##### SIGNAL GstElement::state-change ##### -->
<para>
Is trigered whenever the state of an element changes
</para>

@gstelement: the object which received the signal.
@arg1: the new state of the object

<!-- ##### SIGNAL GstElement::new-pad ##### -->
<para>
Is trigered whenever a new pad is added to an element
</para>

@gstelement: the object which received the signal.
@arg1: the new pad that was added

<!-- ##### SIGNAL GstElement::new-ghost-pad ##### -->
<para>

Is trigered whenever a new ghost pad is added to an element
</para>

@gstelement: the object which received the signal.
@arg1: the new ghost pad that was added

<!-- ##### SIGNAL GstElement::error ##### -->
<para>
Is trigered whenever an error occured

</para>

@gstelement: the object which received the signal.
@arg1: the error message

