<!DOCTYPE book PUBLIC "-//GNOME//DTD DocBook PNG Variant V1.0//EN" "" [ 
<!ENTITY TITLEPAGE SYSTEM "titlepage.sgml">

<!ENTITY INTRO SYSTEM "intro.sgml">

<!ENTITY CONCEPTS SYSTEM "concepts.sgml">
]>

<book id="index">
  &TITLEPAGE;
      
<!-- ############# Overview - part ############### -->

  <part id="introduction"><title>Introduction</title>
    <partintro>
      <para>
	<application>GStreamer</application> is a framework for creating
	streaming media applications.  It is extremely powerful and versatile,
	and this versatility stems in part from its modularity, and its ability
	to incorporate new modules seamlessly into its framework.
	This document describes how to extend the capabilities of
	<application>GStreamer</application> by creating new plugins.
      </para>
      <para>
	It first describes the concepts required and the ways in which
	<application>GStreamer</application> can be extended. It then goes
	through a worked example of how to write a simple filter (for data
	processing), and how to test and debug it.  More advanced concepts are
	then introduced, with worked examples of each.  Next, writing source
	and sink elements (for performing input and output) is discussed.
	Finally, checklists of things to be sure to do when extending
	<application>GStreamer</application> are presented.
      </para>
    </partintro>

      &INTRO;
  </part>

<!-- ############ Basic concepts - part ############# -->

  <part id="basic-concepts"><title>Basic concepts</title>
    <partintro>
      <para>

	This section introduces the basic concepts required to understand the
	issues involved in extending <application>GStreamer</application>

      </para>
    </partintro>

      &CONCEPTS;

  </part>

<!-- ############ Building A Filter - part ############# -->
</book>



GStreamer Filter Writer's Guide
===============================

Outline:

Basic concepts
	Chain vs loop elements
	Scheduling
	Buffers
	Typing and Properties
	Metadata
Building our first filter
	Constructing the boilerplate
		Doing it the easy way with FilterFactory
		  (NOTE: FilterFactory doesn't exist yet)
		Doing it the hard way with G[tk]Object
	An identity filter
		Building an object with pads
		Attaching functions
		The chain function
	The plugin_init function
		Registering the types
		Registering the filter
Building a simple test application
	Initialization
	Instantiating the plugins
	  (NOTE: we really should have a debugging Sink)
	Connecting them
	Running the pipeline
Loop-based Elements
	How scheduling works, aka pushing and pulling
	How a loopfunc works, aka pulling and pushing
	Adding a second output
		Identity is now a tee
		Modifying the test application
Types and Properties
	Building a simple format for testing
	A simple MIME type
	Type properties
	Typefind functions and autopluggin
Buffers and Metadata
	Anatomy of a Buffer
	Refcounts and mutability
	Metadata
		How Properties work efficiently
		Metadata mutability
		  (FIXME: this is an unsolved problem)
Sources and Sinks
	Writing a source
		Pull vs loop based
		Region pulling
		  (NOTE: somewhere explain how filters use this)
	Writing a sink
		Gee, that was easy
State management
	What are states?
	Mangaging filter state
Checklist
	Things to check when writing a filter
	Things to check when writing a source or sink



=====

Omega: a chain-based element has chain functions on each sink pad, the
	connected source pad may directly call (i.e. on the stack) the chain
	function
Omega: each chain function is responsible for doing something useful,
	generally processing the buffer and pushing out the other end
Omega: a loop-based element has a single function attatched to the element
	(not tha pads) that spins in a loop calling gst_pad_pull(sinkpad),
	do stuff, gst_pad_push(srcpad)

