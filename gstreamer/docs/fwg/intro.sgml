<chapter id="cha-doicare">
  <title>Do I care?</title>
  <para>
    This guide explains how to write new modules for GStreamer.  It is
    relevant to:
  </para>
  <itemizedlist>
    <listitem>
      <para>
	Anyone who wants to add support for new input and output
	devices, often called sources and sinks.  For example,
	adding the ability to write to a new video output system
	could be done by writing an appropriate sink plugin.
      </para>
    </listitem>
    <listitem>
      <para>
	Anyone who wants to add support for new ways of processing
	data in GStreamer, often called
	filters.  For example, a new data format converter could be
	created.
      </para>
    </listitem>
    <listitem>
      <para>
	Anyone who wants to extend GStreamer in
	any way: you need to have an understanding of how the plugin system
	works before you can understand the constraints it places on the
	rest of the code.  And you might be surprised at how much can be
	done with plugins.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    This guide is not relevant to you if you only want to use the existing
    functionality of GStreamer, or use an application which uses GStreamer.
    You lot can go away.  Shoo...  (You might find the <emphasis>GStreamer
    Application Development Manual</emphasis> helpful though.)
  </para>
</chapter>

<chapter id="cha-prelimreading">
  <title>Preliminary reading</title>
  <para>
    The reader should be familiar with the basic workings of
    <application>GStreamer</application>.  For a gentle introduction to
    GStreamer, you may wish to read the <emphasis>GStreamer Application
    Development Manual</emphasis>.  Since <application>GStreamer</application>
    adheres to the GObject programming model, the reader is also assumed to
    understand the basics of GObject.
  </para>
</chapter>

<chapter id="cha-structure">
  <title>Structure of this guide</title>
  <para>
    The <application>GStreamer</application> API for developing plugins is 
    rather extensive and powerful. We will first try to get you up and running
    with a simple plugin as fast as possible. We will then gradually add more 
    features to our example plugin. The basic topics will be:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Short overview of the GStreamer concepts. People familiar with the 
	<emphasis>GStreamer Application Development Manual</emphasis> can use
	this short overview to refresh their memory.
      </para>
    </listitem>
    <listitem>
      <para>
        Introduction to the basic structure of the plugin. We will cover all the
	different steps you have to perform in order to build a plugin. This will
	include a general overview of the structure of your source files.
      </para>
    </listitem>
    <listitem>
      <para>
        Creating the plugin boilerplate. We will show you how to define and set up
	the different aspects for creating a plugin. This will cover extending the 
	GstElement class and creating the elementfactory structures. This will include
	setting up the .h and .c files of your plugin.
      </para>
    </listitem>
    <listitem>
      <para>
        Defining the entry point of the plugin and registering the elementfactory.
	After this step your plugin will become available for application programmers.
      </para>
    </listitem>
    <listitem>
      <para>
        Setting up the basic components of the element like adding pads and setting
	up the scheduling entry points of your plugin.
      </para>
    </listitem>
    <listitem>
      <para>
        Adding arguments and signals to the plugin. Users of your plugin will be
	able to listen for specific events your plugin generates as well as change and
	adjust the different properties of your plugin.
      </para>
    </listitem>
    <listitem>
      <para>
        Compiling and testing the basic plugin.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    After this first section, you should be able to create a simple plugin. We will then
    introduce the more advanced concepts of plugins, including:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        Adding padtemplates to the plugin. This will allow your plugin to become fully
	integrated in the GStreamer plugin registry and will allow users of your plugin 
	to know what media types your plugin operates on.
      </para>
    </listitem>
    <listitem>
      <para>
        Adding new mime-types to the registry along with typedetect functions. This will allow
	your plugin to operate on a completely new media type.
      </para>
    </listitem>
    <listitem>
      <para>
        Adding caps to the plugins input pads. This will allow other plugins to know what
	media type your plugin is handling at runtime.
      </para>
    </listitem>
    <listitem>
      <para>
        Choosing between a loop-based or a chain-based plugin. We will teach you how to 
	create plugins with a more complicated input/output behaviour.
      </para>
    </listitem>
    <listitem>
      <para>
        Adding request pads to the plugin. Request pads allow the application programmer
	to let your plugin dynamically create a pad based on a template.
      </para>
    </listitem>
    <listitem>
      <para>
        Caps negotiation will show you how your plugin can addapt to the plugins it 
	is connected to.
      </para>
    </listitem>
    <listitem>
      <para>
        Creating compound and complex elements by extending from a GstBin. This will
	allow you to create plugins that have other plugins embedded in them.
      </para>
    </listitem>
    <listitem>
      <para>
        Creating custom schedulers when the default schedulers are insufficient.
      </para>
    </listitem>
    <listitem>
      <para>
        Creating custom autopluggers when the default ones are insufficient for your needs.
      </para>
    </listitem>
  </itemizedlist>
  <para>
    As you can see, there a lot to learn, so let's get started...
  </para>

</chapter>
