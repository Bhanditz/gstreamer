<chapter id="chapter-gnome">
  <title>GNOME integration</title>
  <para> 
    GStreamer is fairly easy to integrate with GNOME applications.
    GStreamer uses libxml 2.0, GLib 2.0 and popt, as do all other
    GNOME applications.
    There are however some basic issues you need to address in your GNOME
    applications.
  </para>
 
  <sect1>
    <title>Command line options</title>
    <para>
      GNOME applications call gnome_program_init () to parse command-line
      options and initialize the necessary gnome modules.
      GStreamer applications normally call gst_init (&amp;argc, &amp;argv) to
      do the same for GStreamer.
    </para>
    <para>
      Each of these two swallows the program options passed to the program,
      so we need a different way to allow both GNOME and GStreamer to parse
      the command-line options.  This is shown in the following example.
    </para>  

    <programlisting>
<!-- example-begin gnome.c a -->
<![CDATA[
#include <gnome.h>
#include <gst/gst.h>

int
main (int argc, char **argv)
{
  GstPoptOption options[] = {
          { NULL, '\0', POPT_ARG_INCLUDE_TABLE, NULL, 0, "GStreamer", NULL },
            POPT_TABLEEND
        };
  GnomeProgram *program;
  poptContext context;
  const gchar **argvn;

  GstElement *pipeline;
  GstElement *src, *sink;

  options[0].arg = (void *) gst_init_get_popt_table ();
  g_print ("Calling gnome_program_init with the GStreamer popt table\n");
  /* gnome_program_init will initialize GStreamer now
   * as a side effect of having the GStreamer popt table passed. */
  if (! (program = gnome_program_init ("my_package", "0.1", LIBGNOMEUI_MODULE,
                                       argc, argv,
                                       GNOME_PARAM_POPT_TABLE, options,
                                       NULL)))
    g_error ("gnome_program_init failed");

  g_print ("Getting gnome-program popt context\n");
  g_object_get (program, "popt-context", &amp;context, NULL);
  argvn = poptGetArgs (context);
  if (!argvn) {
    g_print ("Run this example with some arguments to see how it works.\n");
    return 0;
  }

  g_print ("Printing rest of arguments\n");
  while (*argvn) {
    g_print ("argument: %s\n", *argvn);
    ++argvn;
  }

  /* do some GStreamer things to show everything's initialized properly */
  g_print ("Doing some GStreamer stuff to show that everything works\n");
  pipeline = gst_pipeline_new ("pipeline");
  src = gst_element_factory_make ("fakesrc", "src");
  sink = gst_element_factory_make ("fakesink", "sink");
  gst_bin_add_many (GST_BIN (pipeline), src, sink, NULL);
  gst_element_link (src, sink);
  gst_element_set_state (pipeline, GST_STATE_PLAYING);
  gst_bin_iterate (GST_BIN (pipeline));
  gst_element_set_state (pipeline, GST_STATE_NULL);

  return 0;
}
]]>
<!-- example-end gnome.c a -->
    </programlisting>
    <para>
      If you try out this program, you will see that when called with
      --help, it will print out both GStreamer and GNOME help arguments.
      All of the arguments that didn't belong to either end up in the
      argvn pointer array.
    </para>
    <para>
      FIXME: flesh this out more.  How do we get the GStreamer arguments
      at the end ?
      FIXME: add a GConf bit.
    </para>
  </sect1>
</chapter>
