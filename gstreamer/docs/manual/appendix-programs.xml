<chapter id="chapter-programs">
  <title>Programs</title>
  <para> 
  </para>

  <sect1 id="section-programs-gst-register">
    <title><command>gst-register</command></title>
    <para> 
      <command>gst-register</command> is used to rebuild the database of plugins.
      It is used after a new plugin has been added to the system. The plugin database
      can be found, by default, in <filename>/etc/gstreamer/reg.xml</filename>.
    </para>
  </sect1>

  <sect1 id="section-programs-gst-launch">
    <title><command>gst-launch</command></title>
    <para> 
      This is a tool that will construct pipelines based on a command-line
      syntax.
    </para> 
    <para> 
      A simple commandline to play a mp3 audio file looks like:

    <screen>
gst-launch filesrc location=hello.mp3 ! mad ! osssink
    </screen>

      A more complex pipeline looks like:

    <screen>
gst-launch filesrc location=redpill.vob ! mpegdemux name=demux \
 demux.audio_00! { ac3parse ! a52dec ! osssink } \
 demux.video_00! { mpeg2dec ! xvideosink }
    </screen>

	<xref linkend="section-programs-gst-launch-more-examples"/> lists more gst-launch commandlines.

    </para>
    <para>
      You can also use the parser in you own
      code. <application>GStreamer</application> provides a function
      gst_parse_launch () that you can use to construct a pipeline.
      The following program lets you create an MP3 pipeline using the
      gst_parse_launch () function:
    </para>
    <programlisting>
#include &lt;gst/gst.h&gt;

int
main (int argc, char *argv[])
{
  GstElement *pipeline;
  GstElement *filesrc;
  GError *error = NULL;

  gst_init (&amp;argc, &amp;argv);

  if (argc != 2) {
    g_print ("usage: %s &lt;filename&gt;\n", argv[0]);
    return -1;
  }

  pipeline = gst_parse_launch ("filesrc name=my_filesrc ! mad ! osssink", &amp;error);
  if (!pipeline) {
    g_print ("Parse error: %s\n", error->message);
    exit (1);
  }
  
  filesrc = gst_bin_get_by_name (GST_BIN (pipeline), "my_filesrc");
  g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);

  gst_element_set_state (pipeline, GST_STATE_PLAYING);

  while (gst_bin_iterate (GST_BIN (pipeline)));

  gst_element_set_state (pipeline, GST_STATE_NULL);

  return 0;
}
    </programlisting>
    <para>
      Note how we can retrieve the filesrc element from the constructed bin using the
      element name.
    </para>
    <sect2>
      <title>Grammar Reference</title>
      <para>
        The <command>gst-launch</command> syntax is processed by a flex/bison parser. This section
        is intended to provide a full specification of the grammar; any deviations from this
        specification is considered a bug.
      </para>
      <sect3>
        <title>Elements</title>
        <screen>
          ... mad ...
        </screen>
        <para>
          A bare identifier (a string beginning with a letter and containing
          only letters, numbers, dashes, underscores, percent signs, or colons)
          will create an element from a given element factory. In this example,
          an instance of the "mad" MP3 decoding plugin will be created.
        </para>
      </sect3>          
      <sect3>
        <title>Links</title>
        <screen>
          ... !sink ...
        </screen>
        <para>
          An exclamation point, optionally having a qualified pad name (an the name of the pad,
          optionally preceded by the name of the element) on both sides, will link two pads. If
          the source pad is not specified, a source pad from the immediately preceding element
          will be automatically chosen. If the sink pad is not specified, a sink pad from the next
          element to be constructed will be chosen. An attempt will be made to find compatible
          pads. Pad names may be preceded by an element name, as in
          <computeroutput>my_element_name.sink_pad</computeroutput>.
        </para>
      </sect3>          
      <sect3>
        <title>Properties</title>
        <screen>
          ... location="http://gstreamer.net" ...
        </screen>
        <para>
          The name of a property, optionally qualified with an element name, and a value,
          separated by an equals sign, will set a property on an element. If the element is not
          specified, the previous element is assumed. Strings can optionally be enclosed in
          quotation marks. Characters in strings may be escaped with the backtick
          (<literal>\</literal>). If the right-hand side is all digits, it is considered to be an
          integer. If it is all digits and a decimal point, it is a double. If it is "true",
          "false", "TRUE", or "FALSE" it is considered to be boolean. Otherwise, it is parsed as a
          string. The type of the property is determined later on in the parsing, and the value is
          converted to the target type. This conversion is not guaranteed to work, it relies on
          the g_value_convert routines. No error message will be displayed on an invalid
          conversion, due to limitations in the value convert API.
        </para>
		<para>
          The list of properties an element supports can be found out using
          <userinput>gst-inspect elemnt-name</userinput>.
		</para>
      </sect3>          
      <sect3>
        <title>Bins, Threads, and Pipelines</title>
        <screen>
          ( ... )
        </screen>
        <para>
          A pipeline description between parentheses is placed into a bin. The open paren may be
          preceded by a type name, as in <computeroutput>jackbin.( ... )</computeroutput> to make
          a bin of a specified type. Square brackets '[ ]' make pipelines, and curly braces '{ }' make
          threads. The default toplevel bin type is a pipeline, although putting the whole
          description within parentheses or braces can override this default.
        </para>
      </sect3>          
    </sect2>
    <sect2 id="section-programs-gst-launch-more-examples">
      <title>More Examples</title>
      <para>
        This chapter collects some more complex pipelines. The examples are split into several lines,
        so make sure to include the trailing backslashes.
		When modifying the pipelines and seeking for the right element to insert, a grep of the gst-inspect
		output often gives a starting point:
		<screen>
gst-inspect | grep "avi"
		</screen>
		Another way is to do:
		<screen>
gst-launch filesrc location=video.avi ! decodebin name=d ! xvimagesink d. ! { queue ! alsasink } -v
		</screen>
		and look on the output, which plugins it chooses.
      </para>
      <para> 
        Play a remote mp3 audio file:
        <screen>
gst-launch gnomevfssrc location=http://www.server.org/hello.mp3 ! mad ! alsasink
        </screen>
      </para>
      <para> 
        Play a local mp3 audio file with visualisation:
        <screen>
gst-launch filesrc location=Hello.mp3 ! mad ! tee name=t ! \
  { queue ! osssink } \
  { t. ! queue ! synaesthesia ! ffmpegcolorspace ! xvimagesink }
        </screen>
      </para>
     <para> 
        Play a local ogg audio file:
        <screen>
gst-launch filesrc location=file.ogg ! oggdemux ! vorbisdec ! audioconvert ! audioscale ! alsasink
        </screen>
      </para>
      <para> 
        Play a local ogg video file:
        <screen>
gst-launch filesrc location=file.ogg ! oggdemux name=demux \
  { demux. ! queue ! theoradec ! ffmpegcolorspace ! videoscale ! xvimagesink } \
  { demux. ! queue ! vorbisdec ! audioconvert ! audioscale ! alsasink }
        </screen>
      </para>
      <para>
        Play a local avi video file:
       <screen>
gst-launch filesrc location=video.avi ! mpegdemux name=demux \
  demux.audio_00! { queue ! ac3parse ! a52dec ! osssink } \
  demux.video_00! { queue ! mpeg2dec ! xvideosink }
        </screen>
      </para>
      <para>
        Transcoding an audio file from one format into another:
       <screen>
gst-launch filesrc location=file.ogg ! oggdemux ! vorbisdec ! audioconvert ! flacenc ! filesink location=file.flac
       </screen>
       <screen>
gst-launch filesrc location=file.mp3 ! id3demus ! mad ! audioconvert ! rawvorbisenc ! oggmux ! filesink location=file.ogg
        </screen>
      </para>
      <para>
        Transcoding an dvd video into a ogg video:
       <screen>
gst-launch-0.8 oggmux name=mux ! filesink location=/tmp/file.ogg \
  { dvdreadsrc location=/dev/cdrom ! dvddemux name=demux.audio_00 ! \
    { queue ! a52dec ! audioconvert ! rawvorbisenc ! queue ! mux. } \
    { demux.video_00 ! queue ! mpeg2dec ! ffcolorspace ! videoscale ! video/x-raw-yuv,width=384,height=288 ! tee name=t ! \
      { queue ! theoraenc ! queue ! mux. } \
    } \
  } \
  { t. ! queue ! ffcolorspace ! ximagesink }
        </screen>
      </para>

	</sect2>
  </sect1>

  <sect1 id="section-programs-gst-inspect">
    <title><command>gst-inspect</command></title>
    <para> 
      This is a tool to query a plugin or an element about its properties.
    </para> 
    <para> 
      To query the information about the element mad, you would specify:
    </para> 

    <screen>
gst-inspect mad
    </screen>

    <para> 
      Below is the output of a query for the osssink element:
    </para> 

    <screen>
Factory Details:
  Long name:	Audio Sink (OSS)
  Class:	Sink/Audio
  Description:	Output to a sound card via OSS
  Version:	0.3.3.1
  Author(s):	Erik Walthinsen &lt;omega@cse.ogi.edu&gt;, Wim Taymans &lt;wim.taymans@chello.be&gt;
  Copyright:	(C) 1999

GObject
 +----GstObject
       +----GstElement
             +----GstOssSink

Pad Templates:
  SINK template: 'sink'
    Availability: Always
    Capabilities:
      'osssink_sink':
        MIME type: 'audio/raw':
        format: String: int
        endianness: Integer: 1234
        width: List:
          Integer: 8
          Integer: 16
        depth: List:
          Integer: 8
          Integer: 16
        channels: Integer range: 1 - 2
        law: Integer: 0
        signed: List:
          Boolean: FALSE
          Boolean: TRUE
        rate: Integer range: 1000 - 48000


Element Flags:
  GST_ELEMENT_THREADSUGGESTED

Element Implementation:
  No loopfunc(), must be chain-based or not configured yet
  Has change_state() function: gst_osssink_change_state
  Has custom save_thyself() function: gst_element_save_thyself
  Has custom restore_thyself() function: gst_element_restore_thyself

Clocking Interaction:
  element requires a clock
  element provides a clock: GstOssClock

Pads:
  SINK: 'sink'
    Implementation:
      Has chainfunc(): 0x40056fc0
    Pad Template: 'sink'

Element Arguments:
  name                                    : String (Default "element")
  device                                  : String (Default "/dev/dsp")
  mute                                    : Boolean (Default false)
  format                                  : Integer (Default 16)
  channels                                : Enum "GstAudiosinkChannels" (default 1)
    (0): 	Silence
    (1): 	Mono
    (2): 	Stereo
  frequency                               : Integer (Default 11025)
  fragment                                : Integer (Default 6)
  buffer-size                             : Integer (Default 4096)

Element Signals:
  "handoff" :	 void user_function (GstOssSink* object, 
    				gpointer user_data);
    </screen>

    <para> 
      To query the information about a plugin, you would do:
    </para> 

    <screen>
gst-inspect gstelements
    </screen>
  </sect1>

</chapter>
