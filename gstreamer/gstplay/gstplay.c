/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#include <config.h>

//#define DEBUG_ENABLED

#include <glade/glade.h>
#include <gst/gstclock.h>

#include "gstplay.h"

#include "callbacks.h"
#include "interface.h"

#define MUTEX_STATUS() (g_mutex_trylock(gdk_threads_mutex)? g_mutex_unlock(gdk_threads_mutex), "was not locked" : "was locked")

#define BUFFER 20

static gboolean idle_func(gpointer data);
static gint start_from_file(guchar *filename); 

GstElement *show;
GstElement *audio_play;
GstElement *src;
GstElement *parse;
GstElement *pipeline;
GstPlayState state;
gboolean picture_shown = FALSE;
guchar statusline[200];
guchar *statustext = "stopped";
GtkWidget *status_area;
GtkWidget *video;
GtkAdjustment *adjustment;
GtkWidget *play_button;
GtkWidget *pause_button;
GtkWidget *stop_button;
GtkFileSelection *open_file_selection;

static void frame_displayed(GstSrc *asrc) 
{
  int size, time, frame_time = 0, src_pos;
  guint mux_rate;
  static int prev_time = -1;

  if (!parse) return;
  DEBUG("gstplay: frame displayed %s\n", MUTEX_STATUS());

  mux_rate = gst_util_get_int_arg(GTK_OBJECT(parse),"mux_rate");
  size = gst_util_get_int_arg(GTK_OBJECT(src),"size");
  time = (size*8)/mux_rate;
  frame_time = gst_util_get_int_arg(GTK_OBJECT(show),"frame_time");
  src_pos = gst_util_get_int_arg(GTK_OBJECT(src),"offset");
  frame_time = (src_pos*8)/mux_rate;

  if (frame_time >= prev_time)  {
    
    g_snprintf(statusline, 200, "%02d:%02d / %02d:%02d\n", 
		  frame_time/60, frame_time%60,
		  time/60, time%60);

    //printf("%d %d %g\n", frame_time, size, frame_time*100.0/size);

    update_status_area(status_area);
    if (state == GSTPLAY_PLAYING)
      update_slider(adjustment, src_pos*100.0/size);
  }
  picture_shown = TRUE;

  prev_time = frame_time;
  DEBUG("gstplay: frame displayed end %s\n", MUTEX_STATUS());
}

static gboolean idle_func(gpointer data) {
  DEBUG("idle start %s\n",MUTEX_STATUS());
  gst_bin_iterate(GST_BIN(data));
  DEBUG("idle stop %s\n",MUTEX_STATUS());
  return TRUE;
}

static void eof(GstSrc *src) {
  change_state(GSTPLAY_PAUSE);
  picture_shown = TRUE;
}

void show_next_picture() {
  picture_shown = FALSE;
  DEBUG("gstplay: next picture %s\n", MUTEX_STATUS());
  while (!picture_shown) {
    gdk_threads_leave();
    gst_src_push(GST_SRC(src));
    gdk_threads_enter();
  }
  DEBUG("gstplay: next found %s\n", MUTEX_STATUS());
}

static void mute_audio(gboolean mute) {
  gtk_object_set(GTK_OBJECT(audio_play),"mute",mute,NULL);
}

static void gstplay_tear_down() 
{
  g_print("setting to NULL state\n");
  gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_NULL);
}

static void  
target_drag_data_received  (GtkWidget          *widget,
                            GdkDragContext     *context,
                            gint                x,
                            gint                y,
                            GtkSelectionData   *data,
                            guint               info,
                            guint               time)
{
  if (strstr(data->data, "file:")) {
    g_print("Got: %s\n",data->data);
    start_from_file(g_strchomp(&data->data[5]));
  }
}

void
on_exit_menu_activate                 (GtkMenuItem     *menuitem,
                                       gpointer         user_data)
{
  gdk_threads_leave();
  gstplay_tear_down();
  gdk_threads_enter();
  gst_main_quit();
}

void on_ok_button1_clicked             (GtkButton     *button,
                                        GtkFileSelection *sel)
{
  gchar *selected_filename;

  selected_filename = gtk_file_selection_get_filename (GTK_FILE_SELECTION(open_file_selection));
  start_from_file(selected_filename);
}

gint on_gstplay_delete_event(GtkWidget *widget, GdkEvent *event, gpointer data)
{
  gdk_threads_leave();
  gstplay_tear_down();
  gdk_threads_enter();
  return FALSE;
}

void change_state(GstPlayState new_state) {

  if (new_state == state) return;
  switch (new_state) { 
    case GSTPLAY_PLAYING:
      mute_audio(FALSE);
      statustext = "playing";
      update_status_area(status_area);
      gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_READY);
      gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_PLAYING);
      gtk_idle_add(idle_func, pipeline);
      state = GSTPLAY_PLAYING;
      update_buttons(0);
      break;
    case GSTPLAY_PAUSE:
      statustext = "paused";
      update_status_area(status_area);
      if (state != GSTPLAY_STOPPED) gtk_idle_remove_by_data(pipeline);
      //gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_PAUSED);
      mute_audio(TRUE);
      state = GSTPLAY_PAUSE;
      update_buttons(1);
      break;
    case GSTPLAY_STOPPED:
      if (state != GSTPLAY_PAUSE) gtk_idle_remove_by_data(pipeline);
      //gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_NULL);
      statustext = "stopped";
      update_status_area(status_area);
      mute_audio(TRUE);
      state = GSTPLAY_STOPPED;
      gtk_object_set(GTK_OBJECT(src),"offset",0,NULL);
      update_buttons(2);
      update_slider(adjustment, 0.0);
      //show_next_picture();
      break;
  }
}

static gint start_from_file(guchar *filename) 
{
  src = gst_elementfactory_make("disksrc", "disk_src");
  g_return_val_if_fail(src != NULL, -1);
  g_print("should be using file '%s'\n",filename);
  gtk_object_set(GTK_OBJECT(src),"location",filename,NULL);

  gst_pipeline_add_src(GST_PIPELINE(pipeline),GST_ELEMENT(src));
  gtk_signal_connect(GTK_OBJECT(src),"eos",
                       GTK_SIGNAL_FUNC(eof),NULL);

  if (!gst_pipeline_autoplug(GST_PIPELINE(pipeline))) {
    g_print("unable to handle stream\n");
    exit(-1);
  }

  if (GST_PAD_CONNECTED(gst_element_get_pad(show, "sink"))) {
    gtk_widget_show(video);
  }
  g_print("setting to READY state\n");
  gst_element_set_state(GST_ELEMENT(pipeline),GST_STATE_READY);

  state = GSTPLAY_STOPPED;

  change_state(GSTPLAY_PLAYING);

  return 0;
}

static GtkTargetEntry target_table[] = {
   { "text/plain", 0, 0 }
};

int
main (int argc, char *argv[])
{
  GladeXML *xml;
  GtkWidget *slider, *gstplay;

  bindtextdomain (PACKAGE, PACKAGE_LOCALE_DIR);
  textdomain (PACKAGE);

  gst_init(&argc,&argv);
  gnome_init ("gstreamer", VERSION, argc, argv);
  glade_init();
  glade_gnome_init();

  g_print("using %s\n", DATADIR"gstplay.glade");
  /* load the interface */
  xml = glade_xml_new(DATADIR "gstplay.glade", "gstplay");

  status_area = glade_xml_get_widget(xml, "status_area");
  slider = glade_xml_get_widget(xml, "slider");
  {
    GtkArg arg;
    GtkRange *range;
    arg.name = "adjustment";
    gtk_object_getv(GTK_OBJECT(slider),1,&arg);
    range = GTK_RANGE(GTK_VALUE_POINTER(arg));
    adjustment = gtk_range_get_adjustment(range);
    gtk_signal_connect(GTK_OBJECT(adjustment),"value_changed",
                    GTK_SIGNAL_FUNC(on_hscale1_value_changed),NULL);
  }
  play_button = glade_xml_get_widget(xml, "toggle_play");
  pause_button = glade_xml_get_widget(xml, "toggle_pause");
  stop_button = glade_xml_get_widget(xml, "toggle_stop");

  gstplay = glade_xml_get_widget(xml, "gstplay");
  gtk_drag_dest_set (gstplay,
                     GTK_DEST_DEFAULT_ALL,
	             target_table, 1,
	             GDK_ACTION_COPY);
  gtk_signal_connect (GTK_OBJECT (gstplay), "drag_data_received",
	              GTK_SIGNAL_FUNC (target_drag_data_received),
	              NULL);

  g_snprintf(statusline, 200, "seeking"); 

  /* create a new bin to hold the elements */
  pipeline = gst_pipeline_new("pipeline");
  g_assert(pipeline != NULL);

  /* and an audio sink */
  audio_play = gst_elementfactory_make("audiosink","play_audio");
  g_return_val_if_fail(audio_play != NULL, -1);

  /* and a video sink */
  show = gst_elementfactory_make("videosink","show");
  g_return_val_if_fail(show != NULL, -1);
  gtk_object_set(GTK_OBJECT(show),"xv_enabled",FALSE,NULL);
  gtk_signal_connect(GTK_OBJECT(show),"frame_displayed",
                      GTK_SIGNAL_FUNC(frame_displayed),NULL);

  video = gst_util_get_widget_arg(GTK_OBJECT(show),"widget");
  gnome_dock_set_client_area(GNOME_DOCK(glade_xml_get_widget(xml, "dock1")),
		  video);

  gst_pipeline_add_sink(GST_PIPELINE(pipeline), audio_play);
  gst_pipeline_add_sink(GST_PIPELINE(pipeline), show);

  /* connect the signals in the interface */
  glade_xml_signal_autoconnect(xml);

  if (argc > 1) {
    gint ret;
    
    ret = start_from_file(argv[1]);
    if (ret < 0) exit(ret);
  }

  gst_main();
  return 0;
}

